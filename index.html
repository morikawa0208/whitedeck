<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backpack Dungeon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff;
            color: #1a1a1a;
            touch-action: manipulation;
            overflow: hidden;
        }
        .grid-cell {
            aspect-ratio: 1 / 1;
            border: 1px solid #e5e7eb;
            transition: all 0.2s;
        }
        .item-node {
            cursor: pointer;
            transition: transform 0.1s ease;
        }
        .item-node:active {
            transform: scale(0.95);
        }
        .health-bar {
            height: 4px;
            transition: width 0.3s ease-out;
        }
        .log-container {
            mask-image: linear-gradient(to top, black 80%, transparent 100%);
        }
        /* „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
        @keyframes damage {
            0% { transform: translateX(0); color: #ef4444; }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
        .animate-damage {
            animation: damage 0.3s ease-in-out;
        }
    </style>
</head>
<body class="flex flex-col h-[100svh] sm:h-screen w-full max-w-[360px] sm:max-w-md mx-auto border-x border-gray-100 shadow-xl">

    <!-- Header / Stats -->
    <header class="p-4 border-b border-gray-100 flex justify-between items-center bg-white z-10">
        <div>
            <h1 class="text-xl font-800 tracking-tighter">BACKPACK DUNGEON</h1>
            <p id="floor-text" class="text-xs text-gray-500 uppercase tracking-widest">Floor 1 - Woods</p>
        </div>
        <div class="text-right">
            <div id="gold-text" class="text-sm font-semibold text-yellow-600">0G</div>
            <div id="level-text" class="text-xs text-gray-400">Lv.1 (0/100)</div>
        </div>
    </header>

    <!-- Battle Screen -->
    <main id="battle-area" class="flex-1 overflow-hidden flex flex-col p-4 space-y-4">
        <!-- Enemy Section -->
        <div id="enemy-container" class="flex justify-around items-end min-h-[120px]">
            <!-- Enemies injected here -->
        </div>

        <!-- Log Area -->
        <div id="game-log" class="h-16 text-[10px] text-gray-400 overflow-y-auto log-container flex flex-col-reverse italic">
            <div>Dungeon entered...</div>
        </div>

        <!-- Backpack Grid -->
        <div class="flex-1 flex flex-col justify-center">
            <div class="bg-gray-50 p-2 rounded-2xl shadow-inner border border-gray-200">
                <div id="backpack-grid" class="grid grid-cols-5 gap-1">
                    <!-- 25 Cells (5x5) -->
                </div>
            </div>
            <p class="text-[10px] text-center text-gray-400 mt-2 uppercase tracking-widest">Tap items to use skills or potions</p>
        </div>

        <!-- Player Stats & Actions -->
        <div class="space-y-3 pb-4">
            <div class="flex justify-between items-center px-1">
                <div class="flex-1 mr-4">
                    <div class="flex justify-between text-xs mb-1 font-semibold">
                        <span>HP</span>
                        <span id="player-hp-text">20 / 20</span>
                    </div>
                    <div class="w-full bg-gray-100 rounded-full h-2 overflow-hidden">
                        <div id="player-hp-bar" class="health-bar bg-black w-full"></div>
                    </div>
                </div>
                <div class="flex-1">
                    <div class="flex justify-between text-xs mb-1 font-semibold">
                        <span>MP</span>
                        <span id="player-mp-text">10 / 10</span>
                    </div>
                    <div class="w-full bg-gray-100 rounded-full h-2 overflow-hidden">
                        <div id="player-mp-bar" class="health-bar bg-blue-500 w-full"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3">
                <button id="attack-btn" class="bg-black text-white py-4 rounded-xl font-bold active:bg-gray-800 transition shadow-lg">ATTACK</button>
                <button id="end-turn-btn" class="bg-white border-2 border-black text-black py-4 rounded-xl font-bold active:bg-gray-50 transition">END TURN</button>
            </div>
        </div>
    </main>

    <!-- Bottom Menu -->
    <nav class="border-t border-gray-100 bg-white px-2 py-2 flex justify-between items-center text-[10px] text-gray-500">
        <button id="dungeon-btn" class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-dungeon text-sm"></i>
            <span>„ÉÄ„É≥„Ç∏„Éß„É≥</span>
        </button>
        <button id="ability-btn" class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-person-running text-sm"></i>
            <span>ËÉΩÂäõ</span>
        </button>
        <button class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-shield-halved text-sm"></i>
            <span>Ë£ÖÂÇô</span>
        </button>
        <button class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-wand-sparkles text-sm"></i>
            <span>„Çπ„Ç≠„É´</span>
        </button>
        <button class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-book text-sm"></i>
            <span>„É≠„Ç∞</span>
        </button>
        <button class="flex flex-col items-center gap-1 px-2 py-1 rounded-lg hover:bg-gray-50 active:bg-gray-100 transition">
            <i class="fa-solid fa-gear text-sm"></i>
            <span>„É°„Éã„É•„Éº</span>
        </button>
    </nav>

    <!-- Ability Menu -->
    <div id="ability-panel" class="fixed inset-0 bg-white/95 z-40 hidden flex flex-col p-6 h-[100svh] sm:h-screen w-full max-w-[360px] sm:max-w-md mx-auto">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-800 tracking-wide">ËÉΩÂäõ</h2>
            <button id="ability-close" class="p-2 rounded-lg border border-gray-200 text-gray-600 hover:bg-gray-50 active:bg-gray-100">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="space-y-4 text-sm text-gray-700">
            <div class="border border-gray-200 rounded-xl p-4">
                <div class="text-xs font-semibold text-gray-400 mb-2">STR</div>
                <ul class="list-disc list-inside space-y-1">
                    <li>ÊîªÊíÉÂäõ</li>
                    <li>„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„ÉÄ„É°„Éº„Ç∏Áéá</li>
                    <li>Èò≤Âæ°Ë≤´ÈÄö</li>
                </ul>
            </div>
            <div class="border border-gray-200 rounded-xl p-4">
                <div class="text-xs font-semibold text-gray-400 mb-2">VIT</div>
                <ul class="list-disc list-inside space-y-1">
                    <li>HP</li>
                    <li>HPËá™ÂãïÂõûÂæ©</li>
                    <li>HPÂê∏ÂèéÁéá</li>
                    <li>ÂèçÂ∞ÑÁéá</li>
                </ul>
            </div>
            <div class="border border-gray-200 rounded-xl p-4">
                <div class="text-xs font-semibold text-gray-400 mb-2">DEX</div>
                <ul class="list-disc list-inside space-y-1">
                    <li>„ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá</li>
                    <li>ÂõûÈÅøÁéá</li>
                    <li>ËøΩÂä†„Çø„Éº„É≥</li>
                    <li>„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Áü≠Á∏ÆÁéá</li>
                </ul>
            </div>
            <div class="border border-gray-200 rounded-xl p-4">
                <div class="text-xs font-semibold text-gray-400 mb-2">INT</div>
                <ul class="list-disc list-inside space-y-1">
                    <li>MP</li>
                    <li>MPËá™ÂãïÂõûÂæ©</li>
                    <li>„Çπ„Ç≠„É´Â®ÅÂäõÁéá</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Dungeon Panel -->
    <div id="dungeon-panel" class="fixed inset-0 bg-white/95 z-40 hidden flex flex-col p-6">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-800 tracking-wide">„ÉÄ„É≥„Ç∏„Éß„É≥</h2>
            <button id="dungeon-close" class="p-2 rounded-lg border border-gray-200 text-gray-600 hover:bg-gray-50 active:bg-gray-100">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div id="dungeon-panel-content" class="space-y-4 text-sm text-gray-700"></div>
    </div>

    <!-- Reward / Shop / Level Up Overlays -->
    <div id="overlay" class="fixed inset-0 bg-white/95 z-50 hidden flex flex-col p-8 items-center justify-center text-center h-[100svh] sm:h-screen w-full max-w-[360px] sm:max-w-md mx-auto">
        <h2 id="overlay-title" class="text-3xl font-800 mb-2 italic">VICTORY</h2>
        <p id="overlay-desc" class="text-gray-500 mb-8">You found something...</p>
        <div id="overlay-content" class="w-full space-y-4 mb-8">
            <!-- Dynamic content -->
        </div>
        <button id="overlay-close" class="w-full max-w-xs bg-black text-white py-4 rounded-xl font-bold shadow-xl">CONTINUE</button>
    </div>

    <script>
        // --- Game Constants & State ---
        const GRID_SIZE = 5;
        const state = {
            player: {
                maxHp: 20, hp: 20,
                maxMp: 10, mp: 10,
                baseAtk: 2,
                gold: 0,
                lv: 1, exp: 0, expNext: 100,
                skillPoints: 0,
                backpack: Array(GRID_SIZE * GRID_SIZE).fill(null),
                buffs: { atkMult: 1, mpCostRed: 0 }
            },
            floor: 1,
            enemies: [],
            isPlayerTurn: true,
            turnCount: 0,
            dungeon: {
                maps: [],
                currentMapIndex: null,
                currentNodeIndex: null
            }
        };

        const ITEM_TYPES = {
            WEAPON: 'weapon',
            SKILL: 'skill',
            POTION: 'potion',
            BOOST: 'boost'
        };

        const DATABASE = {
            items: [
                { id: 'rusty_sword', name: 'Rusty Sword', type: ITEM_TYPES.WEAPON, atk: 2, desc: 'ATK +2', price: 10 },
                { id: 'iron_blade', name: 'Iron Blade', type: ITEM_TYPES.WEAPON, atk: 5, desc: 'ATK +5', price: 30 },
                { id: 'fireball', name: 'Fireball', type: ITEM_TYPES.SKILL, mp: 3, dmg: 8, desc: 'Cost 3MP, 8 DMG', price: 20 },
                { id: 'heal_spell', name: 'Heal', type: ITEM_TYPES.SKILL, mp: 4, heal: 6, desc: 'Cost 4MP, +6 HP', price: 25 },
                { id: 'hp_pot', name: 'HP Potion', type: ITEM_TYPES.POTION, heal: 10, desc: '+10 HP (Consumes)', price: 15 },
                { id: 'sharpener', name: 'Sharpener', type: ITEM_TYPES.BOOST, atkMod: 0.5, desc: 'ATK +50%', price: 40 }
            ],
            monsters: [
                { name: 'Slime', hp: 8, atk: 2, gold: 5, exp: 20 },
                { name: 'Goblin', hp: 15, atk: 4, gold: 12, exp: 45 },
                { name: 'Skeleton', hp: 22, atk: 6, gold: 20, exp: 70 },
                { name: 'Gargoyle', hp: 50, atk: 10, gold: 100, exp: 200 }
            ]
        };

        const MAP_TYPES = {
            NORMAL: 'normal',
            SHOP: 'shop',
            NAMED: 'named',
            BOSS: 'boss',
            TREASURE: 'treasure'
        };

        // --- Core UI Logic ---
        function initGrid() {
            const gridEl = document.getElementById('backpack-grid');
            gridEl.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell rounded-lg flex items-center justify-center p-1 text-[8px] text-center font-bold bg-white';
                cell.dataset.index = i;
                cell.onclick = () => handleItemClick(i);
                gridEl.appendChild(cell);
            }
            updateGridDisplay();
        }

        function updateGridDisplay() {
            const cells = document.querySelectorAll('.grid-cell');
            state.player.backpack.forEach((item, i) => {
                if (item) {
                    cells[i].innerHTML = `<div class="w-full h-full flex flex-col items-center justify-center rounded-md p-1 shadow-sm border border-gray-200 bg-white hover:bg-gray-50">
                        <span class="truncate">${item.name}</span>
                        <div class="w-full h-1 mt-1 bg-gray-200 rounded-full overflow-hidden">
                            <div class="h-full bg-black" style="width: 100%"></div>
                        </div>
                    </div>`;
                    cells[i].classList.add('item-node');
                } else {
                    cells[i].innerHTML = '';
                    cells[i].classList.remove('item-node');
                }
            });
        }

        function log(msg) {
            const logEl = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.textContent = msg;
            logEl.prepend(entry);
        }

        function updateStats() {
            document.getElementById('player-hp-text').textContent = `${Math.ceil(state.player.hp)} / ${state.player.maxHp}`;
            document.getElementById('player-hp-bar').style.width = `${(state.player.hp / state.player.maxHp) * 100}%`;
            document.getElementById('player-mp-text').textContent = `${state.player.mp} / ${state.player.maxMp}`;
            document.getElementById('player-mp-bar').style.width = `${(state.player.mp / state.player.maxMp) * 100}%`;
            document.getElementById('gold-text').textContent = `${state.player.gold}G`;
            document.getElementById('level-text').textContent = `Lv.${state.player.lv} (${state.player.exp}/${state.player.expNext})`;
            document.getElementById('floor-text').textContent = getFloorText();
        }

        // --- Battle Logic ---
        function spawnEnemies(nodeType = MAP_TYPES.NORMAL) {
            const baseFloor = state.floor + (nodeType === MAP_TYPES.NAMED ? 2 : nodeType === MAP_TYPES.BOSS ? 5 : 0);
            const count = nodeType === MAP_TYPES.BOSS ? 1 : Math.min(3, Math.ceil(baseFloor / 3));
            state.enemies = [];
            const container = document.getElementById('enemy-container');
            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const monsterBase = DATABASE.monsters[Math.min(DATABASE.monsters.length - 1, Math.floor(baseFloor / 4))];
                const bonusHp = baseFloor * (nodeType === MAP_TYPES.BOSS ? 3 : nodeType === MAP_TYPES.NAMED ? 2 : 1);
                const monster = { ...monsterBase, hp: monsterBase.hp + bonusHp, maxHp: monsterBase.hp + bonusHp, id: i };
                state.enemies.push(monster);

                const el = document.createElement('div');
                el.id = `enemy-${i}`;
                el.className = 'flex flex-col items-center w-24 space-y-2 transform transition duration-500';
                el.innerHTML = `
                    <div class="text-[10px] font-bold uppercase tracking-widest">${monster.name}</div>
                    <div class="w-16 h-16 bg-gray-100 rounded-2xl flex items-center justify-center text-3xl shadow-sm border border-gray-200">
                        ${getMonsterEmoji(monster.name)}
                    </div>
                    <div class="w-full px-2">
                        <div class="flex justify-between text-[8px] font-bold mb-0.5">
                            <span>HP</span><span id="enemy-hp-txt-${i}">${monster.hp}</span>
                        </div>
                        <div class="w-full bg-gray-200 h-1.5 rounded-full overflow-hidden">
                            <div id="enemy-hp-bar-${i}" class="bg-red-500 h-full w-full"></div>
                        </div>
                    </div>
                `;
                container.appendChild(el);
            }
        }

        function getMonsterEmoji(name) {
            if (name === 'Slime') return 'üíß';
            if (name === 'Goblin') return 'üë∫';
            if (name === 'Skeleton') return 'üíÄ';
            if (name === 'Gargoyle') return 'ü¶á';
            return 'üëæ';
        }

        function handleAttack() {
            if (!state.isPlayerTurn || state.enemies.length === 0) return;
            
            // Calc Total ATK
            let totalAtk = state.player.baseAtk;
            let mult = 1;
            state.player.backpack.forEach(item => {
                if (!item) return;
                if (item.type === ITEM_TYPES.WEAPON) totalAtk += item.atk;
                if (item.type === ITEM_TYPES.BOOST && item.atkMod) mult += item.atkMod;
            });
            totalAtk *= mult;

            // Damage first enemy
            const target = state.enemies[0];
            damageEnemy(target, totalAtk);
            checkBattleEnd();
        }

        function damageEnemy(enemy, dmg) {
            enemy.hp -= dmg;
            log(`You hit ${enemy.name} for ${dmg.toFixed(1)}!`);
            
            const el = document.getElementById(`enemy-${enemy.id}`);
            el.classList.add('animate-damage');
            setTimeout(() => el.classList.remove('animate-damage'), 300);

            if (enemy.hp <= 0) {
                state.enemies = state.enemies.filter(e => e.id !== enemy.id);
                document.getElementById(`enemy-${enemy.id}`).style.opacity = '0';
                setTimeout(() => document.getElementById(`enemy-${enemy.id}`)?.remove(), 500);
                log(`${enemy.name} defeated!`);
                
                // Gain rewards immediately
                state.player.gold += enemy.gold;
                state.player.exp += enemy.exp;
                checkLevelUp();
                updateStats();
            } else {
                updateEnemyUI(enemy);
            }
        }

        function updateEnemyUI(enemy) {
            document.getElementById(`enemy-hp-txt-${enemy.id}`).textContent = Math.ceil(enemy.hp);
            document.getElementById(`enemy-hp-bar-${enemy.id}`).style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
        }

        function checkBattleEnd() {
            if (state.enemies.length === 0) {
                setTimeout(() => {
                    const nodeType = getCurrentNode()?.type;
                    const nextLabel = nodeType === MAP_TYPES.BOSS ? getNextMapLabel() : 'Ê¨°„ÅÆ„Éû„Çπ„Å∏';
                    showOverlay('VICTORY', getNodeResultText(nodeType), [
                        { label: nextLabel, action: () => completeNode(nodeType) }
                    ]);
                }, 800);
            }
        }

        function endTurn() {
            if (!state.isPlayerTurn) return;
            state.isPlayerTurn = false;
            log("Enemy turn...");
            
            setTimeout(() => {
                state.enemies.forEach(enemy => {
                    const dmg = enemy.atk;
                    state.player.hp -= dmg;
                    log(`${enemy.name} attacks you for ${dmg}!`);
                });
                
                if (state.player.hp <= 0) {
                    showOverlay('DEFEAT', 'Your journey ends here.', [
                        { label: 'Restart', action: () => window.location.reload() }
                    ]);
                } else {
                    state.isPlayerTurn = true;
                    state.player.mp = Math.min(state.player.maxMp, state.player.mp + 2); // Regen 2 MP
                    log("Your turn! +2 MP");
                    updateStats();
                }
            }, 600);
        }

        function handleItemClick(index) {
            const item = state.player.backpack[index];
            if (!item || !state.isPlayerTurn) return;

            if (item.type === ITEM_TYPES.SKILL) {
                if (state.player.mp >= item.mp) {
                    state.player.mp -= item.mp;
                    if (item.dmg && state.enemies.length > 0) {
                        damageEnemy(state.enemies[0], item.dmg);
                    }
                    if (item.heal) {
                        state.player.hp = Math.min(state.player.maxHp, state.player.hp + item.heal);
                        log(`You cast Heal for ${item.heal}!`);
                    }
                    updateStats();
                    checkBattleEnd();
                } else {
                    log("Not enough MP!");
                }
            } else if (item.type === ITEM_TYPES.POTION) {
                state.player.hp = Math.min(state.player.maxHp, state.player.hp + item.heal);
                log(`Drank potion: +${item.heal} HP`);
                state.player.backpack[index] = null;
                updateGridDisplay();
                updateStats();
            }
        }

        // --- Progression Logic ---
        function checkLevelUp() {
            if (state.player.exp >= state.player.expNext) {
                state.player.lv++;
                state.player.exp -= state.player.expNext;
                state.player.expNext = Math.floor(state.player.expNext * 1.5);
                state.player.maxHp += 5;
                state.player.hp = state.player.maxHp;
                log(`LEVEL UP! Now Lv.${state.player.lv}`);
                
                // Skill Point Choice
                const randomSkills = [DATABASE.items[2], DATABASE.items[3]];
                showOverlay('LEVEL UP', 'Pick a new skill', [
                    { label: randomSkills[0].name, action: () => addItemToBackpack(randomSkills[0]) },
                    { label: randomSkills[1].name, action: () => addItemToBackpack(randomSkills[1]) }
                ]);
            }
        }

        function addItemToBackpack(item) {
            const emptyIdx = state.player.backpack.findIndex(s => s === null);
            if (emptyIdx !== -1) {
                state.player.backpack[emptyIdx] = { ...item };
                updateGridDisplay();
                log(`Acquired ${item.name}!`);
            } else {
                log("Backpack full!");
            }
        }

        function nextFloor() {
            state.floor++;
            spawnEnemies();
            updateStats();
        }

        function showShop(onClose) {
            const pool = DATABASE.items;
            const items = [pool[Math.floor(Math.random()*pool.length)], pool[Math.floor(Math.random()*pool.length)]];
            
            showOverlay('MERCHANT', 'Wares for sale...', [
                { label: `${items[0].name} (${items[0].price}G)`, action: () => buyItem(items[0]) },
                { label: `${items[1].name} (${items[1].price}G)`, action: () => buyItem(items[1]) },
                { label: 'Leave', action: () => { if (onClose) onClose(); } }
            ]);
        }

        function buyItem(item) {
            if (state.player.gold >= item.price) {
                state.player.gold -= item.price;
                addItemToBackpack(item);
                updateStats();
            } else {
                log("Too expensive!");
            }
        }

        // --- Overlay Logic ---
        function showOverlay(title, desc, buttons) {
            document.getElementById('overlay-title').textContent = title;
            document.getElementById('overlay-desc').textContent = desc;
            const content = document.getElementById('overlay-content');
            content.innerHTML = '';
            
            buttons.forEach(btn => {
                const b = document.createElement('button');
                b.className = 'w-full bg-gray-50 border border-gray-200 py-4 rounded-xl font-bold hover:bg-gray-100 transition';
                b.textContent = btn.label;
                b.onclick = () => {
                    document.getElementById('overlay').classList.add('hidden');
                    btn.action();
                };
                content.appendChild(b);
            });
            
            document.getElementById('overlay').classList.remove('hidden');
        }

        // --- Dungeon / Map Logic ---
        function createMaps() {
            return [
                { name: 'Woods', size: 3, nodes: buildNodes(3, [
                    { x: 0, y: 2, type: MAP_TYPES.SHOP },
                    { x: 2, y: 0, type: MAP_TYPES.TREASURE },
                    { x: 1, y: 2, type: MAP_TYPES.NAMED },
                    { x: 2, y: 2, type: MAP_TYPES.BOSS }
                ]) },
                { name: 'Ruins', size: 4, nodes: buildNodes(4, [
                    { x: 0, y: 3, type: MAP_TYPES.SHOP },
                    { x: 3, y: 0, type: MAP_TYPES.TREASURE },
                    { x: 2, y: 1, type: MAP_TYPES.NAMED },
                    { x: 3, y: 3, type: MAP_TYPES.BOSS }
                ]) },
                { name: 'Abyss', size: 4, nodes: buildNodes(4, [
                    { x: 0, y: 3, type: MAP_TYPES.TREASURE },
                    { x: 3, y: 0, type: MAP_TYPES.NAMED },
                    { x: 1, y: 2, type: MAP_TYPES.SHOP },
                    { x: 3, y: 3, type: MAP_TYPES.BOSS }
                ]) }
            ];
        }

        function buildNodes(size, specials) {
            const startX = Math.floor(size / 2);
            const startY = Math.floor(size / 2);
            const nodes = [];
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    nodes.push({
                        x,
                        y,
                        type: MAP_TYPES.NORMAL,
                        unlocked: x === startX && y === startY,
                        cleared: false
                    });
                }
            }
            specials.forEach(({ x, y, type }) => {
                const idx = y * size + x;
                if (nodes[idx]) {
                    nodes[idx].type = type;
                }
            });
            return nodes;
        }

        function initDungeon() {
            state.dungeon.maps = createMaps();
            state.dungeon.currentMapIndex = null;
            state.dungeon.currentNodeIndex = null;
        }

        function getCurrentMap() {
            if (state.dungeon.currentMapIndex === null) return null;
            return state.dungeon.maps[state.dungeon.currentMapIndex];
        }

        function getCurrentNode() {
            const map = getCurrentMap();
            if (!map || state.dungeon.currentNodeIndex === null) return null;
            return map.nodes[state.dungeon.currentNodeIndex];
        }

        function getFloorText() {
            const map = getCurrentMap();
            if (!map) return 'Dungeon Select';
            const clearedCount = map.nodes.filter(node => node.cleared).length;
            return `Map ${state.dungeon.currentMapIndex + 1}: ${map.name} (${clearedCount}/${map.nodes.length})`;
        }

        function openDungeonPanel() {
            renderDungeonPanel();
            document.getElementById('dungeon-panel').classList.remove('hidden');
        }

        function renderDungeonPanel() {
            const content = document.getElementById('dungeon-panel-content');
            content.innerHTML = '';
            const map = getCurrentMap();

            if (!map) {
                const title = document.createElement('div');
                title.className = 'text-xs text-gray-500 uppercase tracking-widest';
                title.textContent = '„ÉÄ„É≥„Ç∏„Éß„É≥ÈÅ∏Êäû';
                content.appendChild(title);

                state.dungeon.maps.forEach((mapData, index) => {
                    const available = index === 0 || state.dungeon.maps[index - 1].cleared;
                    const isCleared = !!mapData.cleared;
                    const btn = document.createElement('button');
                    btn.className = `w-full border rounded-xl p-4 flex items-center justify-between ${available ? 'bg-white border-gray-200 hover:bg-gray-50' : 'bg-gray-50 border-gray-100 text-gray-300'}`;
                    btn.disabled = !available;
                    btn.innerHTML = `
                        <div class="text-left">
                            <div class="font-semibold text-gray-800">${mapData.name}</div>
                            <div class="text-[11px] text-gray-400">${isCleared ? 'CLEARÊ∏à„Åø' : 'ÊîªÁï•ÂèØËÉΩ'}</div>
                        </div>
                        <div class="text-xs text-gray-400">${available ? 'SELECT' : 'LOCKED'}</div>
                    `;
                    btn.onclick = () => selectMap(index);
                    content.appendChild(btn);
                });
                return;
            }

            const header = document.createElement('div');
            header.className = 'text-xs text-gray-500 uppercase tracking-widest';
            header.textContent = `${map.name} „ÅÆ„Éû„ÉÉ„Éó`;
            content.appendChild(header);

            const nodeWrap = document.createElement('div');
            nodeWrap.className = 'grid gap-3';
            nodeWrap.style.gridTemplateColumns = `repeat(${map.size}, minmax(0, 1fr))`;

            map.nodes.forEach((node, index) => {
                const isCurrent = index === state.dungeon.currentNodeIndex;
                const btn = document.createElement('button');
                const active = node.unlocked && !node.cleared;
                const statusText = node.cleared ? 'CLEAR' : node.unlocked ? 'OPEN' : 'LOCK';
                btn.className = `border rounded-xl p-3 text-left space-y-1 ${active ? 'bg-white border-gray-200 hover:bg-gray-50' : 'bg-gray-50 border-gray-100 text-gray-300'} ${isCurrent ? 'ring-2 ring-black' : ''}`;
                btn.disabled = !active;
                btn.innerHTML = `
                    <div class="flex items-center justify-between text-xs font-semibold">
                        <span>${getNodeLabel(node.type)}</span>
                        <span>${statusText}</span>
                    </div>
                    <div class="text-[10px] text-gray-400">Â∫ßÊ®ô (${node.x + 1},${node.y + 1})</div>
                `;
                btn.onclick = () => startNode(index);
                nodeWrap.appendChild(btn);
            });

            content.appendChild(nodeWrap);

            const legend = document.createElement('div');
            legend.className = 'text-[10px] text-gray-400 space-y-1';
            legend.innerHTML = `
                <div>ÈÄöÂ∏∏: ÊïµÊà¶ / Â∫ó: „Ç∑„Éß„ÉÉ„Éó / „Éç„Éº„É†„Éâ: Âº∑Êïµ</div>
                <div>ÂÆùÁÆ±: Â†±ÈÖ¨ / „Éú„Çπ: „Éû„ÉÉ„ÉóÈÄ≤Ë°å</div>
            `;
            content.appendChild(legend);
        }

        function getNodeLabel(type) {
            if (type === MAP_TYPES.SHOP) return 'Â∫ó';
            if (type === MAP_TYPES.NAMED) return '„Éç„Éº„É†„Éâ';
            if (type === MAP_TYPES.BOSS) return '„Éú„Çπ';
            if (type === MAP_TYPES.TREASURE) return 'ÂÆùÁÆ±';
            return 'ÈÄöÂ∏∏';
        }

        function selectMap(index) {
            state.dungeon.currentMapIndex = index;
            state.dungeon.currentNodeIndex = null;
            const map = getCurrentMap();
            const startX = Math.floor(map.size / 2);
            const startY = Math.floor(map.size / 2);
            map.nodes.forEach(node => {
                node.unlocked = node.x === startX && node.y === startY;
                node.cleared = false;
            });
            updateStats();
            renderDungeonPanel();
        }

        function startNode(index) {
            const map = getCurrentMap();
            const node = map?.nodes[index];
            if (!node || !node.unlocked || node.cleared) return;
            state.dungeon.currentNodeIndex = index;
            state.floor = (state.dungeon.currentMapIndex * 10) + index + 1;
            document.getElementById('dungeon-panel').classList.add('hidden');
            document.getElementById('enemy-container').innerHTML = '';
            state.enemies = [];
            updateStats();

            if (node.type === MAP_TYPES.SHOP) {
                showShop(() => completeNode(node.type));
                return;
            }
            if (node.type === MAP_TYPES.TREASURE) {
                showTreasure();
                return;
            }
            spawnEnemies(node.type);
        }

        function showTreasure() {
            const rewardItem = Math.random() > 0.5 ? DATABASE.items[Math.floor(Math.random() * DATABASE.items.length)] : null;
            const goldReward = rewardItem ? 0 : 15 + Math.floor(Math.random() * 15);
            if (rewardItem) {
                showOverlay('TREASURE', `You found ${rewardItem.name}!`, [
                    { label: 'Âèó„ÅëÂèñ„Çã', action: () => { addItemToBackpack(rewardItem); completeNode(MAP_TYPES.TREASURE); } }
                ]);
            } else {
                showOverlay('TREASURE', `You found ${goldReward}G!`, [
                    { label: 'Âèó„ÅëÂèñ„Çã', action: () => { state.player.gold += goldReward; updateStats(); completeNode(MAP_TYPES.TREASURE); } }
                ]);
            }
        }

        function completeNode(nodeType) {
            const map = getCurrentMap();
            const node = getCurrentNode();
            if (!map || !node) return;
            node.cleared = true;
            unlockAdjacentNodes(map, node);
            if (nodeType === MAP_TYPES.BOSS) {
                handleBossClear();
                return;
            }
            state.dungeon.currentNodeIndex = null;
            renderDungeonPanel();
            updateStats();
            openDungeonPanel();
        }

        function handleBossClear() {
            const map = getCurrentMap();
            map.cleared = true;
            const isLastMap = state.dungeon.currentMapIndex === state.dungeon.maps.length - 1;
            if (isLastMap) {
                showOverlay('DUNGEON CLEAR', 'ÊúÄÂæå„ÅÆ„Éú„Çπ„ÇíÊíÉÁ†¥ÔºÅ', [
                    { label: 'ÂÜçÊåëÊà¶', action: () => window.location.reload() }
                ]);
                return;
            }
            showOverlay('MAP CLEAR', 'Ê¨°„ÅÆ„Éû„ÉÉ„Éó„Å∏ÈÄ≤„ÇÇ„ÅÜ', [
                { label: 'Ê¨°„ÅÆ„Éû„ÉÉ„Éó', action: advanceMap }
            ]);
        }

        function advanceMap() {
            state.dungeon.currentMapIndex += 1;
            state.dungeon.currentNodeIndex = null;
            const map = getCurrentMap();
            const startX = Math.floor(map.size / 2);
            const startY = Math.floor(map.size / 2);
            map.nodes.forEach(node => {
                node.unlocked = node.x === startX && node.y === startY;
                node.cleared = false;
            });
            updateStats();
            openDungeonPanel();
        }

        function unlockAdjacentNodes(map, node) {
            const directions = [
                { x: 0, y: -1 },
                { x: 0, y: 1 },
                { x: -1, y: 0 },
                { x: 1, y: 0 }
            ];
            directions.forEach(dir => {
                const nx = node.x + dir.x;
                const ny = node.y + dir.y;
                if (nx < 0 || ny < 0 || nx >= map.size || ny >= map.size) return;
                const idx = ny * map.size + nx;
                const target = map.nodes[idx];
                if (target && !target.cleared) {
                    target.unlocked = true;
                }
            });
        }

        function getNodeResultText(nodeType) {
            if (nodeType === MAP_TYPES.BOSS) return '„Éú„ÇπÊíÉÁ†¥ÔºÅ';
            if (nodeType === MAP_TYPES.NAMED) return 'Âº∑Êïµ„ÇíÂÄí„Åó„ÅüÔºÅ';
            return 'Êà¶ÈóòÂãùÂà©ÔºÅ';
        }

        function getNextMapLabel() {
            const isLastMap = state.dungeon.currentMapIndex === state.dungeon.maps.length - 1;
            return isLastMap ? '„ÉÄ„É≥„Ç∏„Éß„É≥„ÇØ„É™„Ç¢„Å∏' : 'Ê¨°„ÅÆ„Éû„ÉÉ„Éó„Å∏';
        }

        // --- Initialization ---
        window.onload = () => {
            initGrid();
            initDungeon();
            // Start items
            addItemToBackpack(DATABASE.items[0]);
            addItemToBackpack(DATABASE.items[4]);
            
            updateStats();
            log('„ÉÄ„É≥„Ç∏„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');

            document.getElementById('attack-btn').onclick = handleAttack;
            document.getElementById('end-turn-btn').onclick = endTurn;
            document.getElementById('overlay-close').onclick = () => {
                document.getElementById('overlay').classList.add('hidden');
            };
            document.getElementById('ability-btn').onclick = () => {
                document.getElementById('ability-panel').classList.remove('hidden');
            };
            document.getElementById('ability-close').onclick = () => {
                document.getElementById('ability-panel').classList.add('hidden');
            };
            document.getElementById('dungeon-btn').onclick = () => {
                openDungeonPanel();
            };
            document.getElementById('dungeon-close').onclick = () => {
                document.getElementById('dungeon-panel').classList.add('hidden');
            };
        };
    </script>
</body>
</html>
